Опишем здесь работу алгоритма, реализованного в main.cpp
Действовать будем так: будем переводить постфиксную нотацию в инфиксную (в качестве приятного бонуса также получим инфиксную нотацию). 
Как будем подсчитывать финальный ответ? Заведем стек пар из строки и множества чисел. 
Строка будет описывать кусок (валидной) инфиксной записи, а множество чисел из ее пары - 
множество длин слов из языка, который задает этот кусок инфиксной записи. 
Тогда понятно, как обрабатывать множества длин при применении операции: если мы применяем звездочку, то, в силу того, 
что мы действуем по модулю k, нужно добавить в множество для каждого числа, 
уже лежащего в множестве его произведение на все числа от 0 до (k-1). 
Если мы обрабатываем +, то нужно объединить два множества, выражения регулярные выражения которых мы складываем. 
Если же применяем умножение - то нужно в новое множество положить всевозможные суммы из двух множеств (могли брать любое слово из каждого языка). 
В таком случае в конце работы алгоритма на вершине стека лежит пара из регулярного выражения, задающего язык и все возможные длины слов из языка во множестве из пары. 
Проверяем, лежит ли l в нем. 
Итоговая сложность: Бежим по постфиксной нотации O(|alpha|), внутри которой самые “дорогие” операции - получение нового множества при умножении (O(k^2)). В итоге получаем O(|alpha| * k^2).
